---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
Id :: forall (a :: Type). a -> Id a
Pair :: forall (a :: Type). a -> a -> Pair a
Mixed :: forall (a :: Type). Int -> a -> Boolean -> Mixed a
Rec :: forall (a :: Type). { count :: Int, value :: a } -> Rec a
Wrap :: forall (t9 :: Type) (f :: t9 -> Type) (a :: t9). f a -> Wrap @t9 f a
Compose ::
  forall (t16 :: Type) (t20 :: Type) (f :: t16 -> Type) (g :: t20 -> t16) (a :: t20).
    f (g a) -> Compose @t20 f g a
Left' :: forall (a :: Type). a -> Either' a
Right' :: forall (a :: Type). a -> Either' a
NoEq :: forall (a :: Type). a -> NoEq a

Types
Id :: Type -> Type
Pair :: Type -> Type
Mixed :: Type -> Type
Rec :: Type -> Type
Wrap :: forall (t9 :: Type). (t9 -> Type) -> t9 -> Type
Compose :: forall (t16 :: Type) (t20 :: Type). (t16 -> Type) -> (t20 -> t16) -> t20 -> Type
Either' :: Type -> Type
NoEq :: Type -> Type

Data
Id
  Quantified = :0
  Kind = :0

Pair
  Quantified = :0
  Kind = :0

Mixed
  Quantified = :0
  Kind = :0

Rec
  Quantified = :0
  Kind = :0

Wrap
  Quantified = :1
  Kind = :0

Compose
  Quantified = :2
  Kind = :0

Either'
  Quantified = :0
  Kind = :0

NoEq
  Quantified = :0
  Kind = :0


Roles
Id = [Representational]
Pair = [Representational]
Mixed = [Representational]
Rec = [Representational]
Wrap = [Representational, Nominal]
Compose = [Representational, Representational, Nominal]
Either' = [Representational]
NoEq = [Representational]

Derived
derive Eq1 &0 => Eq1 (Wrap @Type &0 :: Type -> Type)
derive forall (&0 :: Type). (Eq1 &1, Eq (&2 &3)) => Eq (Compose @Type @&0 &1 &2 &3 :: Type)
derive Eq1 &0 => Eq1 (Compose @Type @Type &0 &1 :: Type -> Type)
derive Eq &0 => Eq (Id &0 :: Type)
derive Eq &0 => Eq (Either' &0 :: Type)
derive Eq1 (Either' :: Type -> Type)
derive Eq1 (NoEq :: Type -> Type)
derive Eq1 (Id :: Type -> Type)
derive Eq &0 => Eq (Pair &0 :: Type)
derive Eq1 (Pair :: Type -> Type)
derive Eq &0 => Eq (Mixed &0 :: Type)
derive Eq1 (Mixed :: Type -> Type)
derive Eq &0 => Eq (Rec &0 :: Type)
derive Eq1 (Rec :: Type -> Type)
derive (Eq1 &0, Eq &1) => Eq (Wrap @Type &0 &1 :: Type)

Errors
NoInstanceFound { Eq (&1 ~&2) } at [TermDeclaration(Idx::<TermItem>(17))]
NoInstanceFound { Eq (NoEq ~&0) } at [TermDeclaration(Idx::<TermItem>(23))]
