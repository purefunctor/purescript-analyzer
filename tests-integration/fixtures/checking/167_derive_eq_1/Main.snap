---
source: tests-integration/tests/checking/generated.rs
assertion_line: 28
expression: report
---
Terms
Id :: forall (a :: Type). (a :: Type) -> Id (a :: Type)
Pair :: forall (a :: Type). (a :: Type) -> (a :: Type) -> Pair (a :: Type)
Mixed :: forall (a :: Type). Int -> (a :: Type) -> Boolean -> Mixed (a :: Type)
Rec :: forall (a :: Type). { count :: Int, value :: (a :: Type) } -> Rec (a :: Type)
Wrap ::
  forall (t9 :: Type) (f :: (t9 :: Type) -> Type) (a :: (t9 :: Type)).
    (f :: (t9 :: Type) -> Type) (a :: (t9 :: Type)) ->
    Wrap @(t9 :: Type) (f :: (t9 :: Type) -> Type) (a :: (t9 :: Type))
Compose ::
  forall (t16 :: Type) (t20 :: Type) (f :: (t16 :: Type) -> Type)
    (g :: (t20 :: Type) -> (t16 :: Type)) (a :: (t20 :: Type)).
    (f :: (t16 :: Type) -> Type) ((g :: (t20 :: Type) -> (t16 :: Type)) (a :: (t20 :: Type))) ->
    Compose @(t20 :: Type)
      (f :: (t16 :: Type) -> Type)
      (g :: (t20 :: Type) -> (t16 :: Type))
      (a :: (t20 :: Type))
Left' :: forall (a :: Type). (a :: Type) -> Either' (a :: Type)
Right' :: forall (a :: Type). (a :: Type) -> Either' (a :: Type)
NoEq :: forall (a :: Type). (a :: Type) -> NoEq (a :: Type)

Types
Id :: Type -> Type
Pair :: Type -> Type
Mixed :: Type -> Type
Rec :: Type -> Type
Wrap :: forall (t9 :: Type). ((t9 :: Type) -> Type) -> (t9 :: Type) -> Type
Compose ::
  forall (t16 :: Type) (t20 :: Type).
    ((t16 :: Type) -> Type) -> ((t20 :: Type) -> (t16 :: Type)) -> (t20 :: Type) -> Type
Either' :: Type -> Type
NoEq :: Type -> Type

Data
Id
  Quantified = :0
  Kind = :0

Pair
  Quantified = :0
  Kind = :0

Mixed
  Quantified = :0
  Kind = :0

Rec
  Quantified = :0
  Kind = :0

Wrap
  Quantified = :1
  Kind = :0

Compose
  Quantified = :2
  Kind = :0

Either'
  Quantified = :0
  Kind = :0

NoEq
  Quantified = :0
  Kind = :0


Roles
Id = [Representational]
Pair = [Representational]
Mixed = [Representational]
Rec = [Representational]
Wrap = [Representational, Nominal]
Compose = [Representational, Representational, Nominal]
Either' = [Representational]
NoEq = [Representational]

Derived
derive Eq1 (f :: Type -> Type) => Eq1 (Wrap @Type (f :: Type -> Type) :: Type -> Type)
derive forall (t41 :: Type). (Eq1 (f :: Type -> Type), Eq ((g :: (t41 :: Type) -> Type) (a :: (t41 :: Type)))) => Eq (Compose @Type @(t41 :: Type) (f :: Type -> Type) (g :: (t41 :: Type) -> Type) (a :: (t41 :: Type)) :: Type)
derive Eq1 (f :: Type -> Type) => Eq1 (Compose @Type @Type (f :: Type -> Type) (g :: Type -> Type) :: Type -> Type)
derive Eq (a :: Type) => Eq (Id (a :: Type) :: Type)
derive Eq (a :: Type) => Eq (Either' (a :: Type) :: Type)
derive Eq1 (Either' :: Type -> Type)
derive Eq1 (NoEq :: Type -> Type)
derive Eq1 (Id :: Type -> Type)
derive Eq (a :: Type) => Eq (Pair (a :: Type) :: Type)
derive Eq1 (Pair :: Type -> Type)
derive Eq (a :: Type) => Eq (Mixed (a :: Type) :: Type)
derive Eq1 (Mixed :: Type -> Type)
derive Eq (a :: Type) => Eq (Rec (a :: Type) :: Type)
derive Eq1 (Rec :: Type -> Type)
derive (Eq1 (f :: Type -> Type), Eq (a :: Type)) => Eq (Wrap @Type (f :: Type -> Type) (a :: Type) :: Type)

Diagnostics
error[NoInstanceFound]: No instance found for: Eq ((g :: Type -> Type) (~_ :: Type))
  --> 35:1..35:43
   |
35 | derive instance Eq1 f => Eq1 (Compose f g)
   | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error[NoInstanceFound]: No instance found for: Eq (NoEq (~_ :: Type))
  --> 45:1..45:25
   |
45 | derive instance Eq1 NoEq
   | ^~~~~~~~~~~~~~~~~~~~~~~~
