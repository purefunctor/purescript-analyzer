---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
Proxy :: forall (k :: Type) (a :: (k :: Type)). Proxy @(k :: Type) (a :: (k :: Type))
deriveAppended ::
  forall (appended :: Symbol).
    Append "Hello" "World" (appended :: Symbol) => Proxy @Symbol (appended :: Symbol)
deriveLeft ::
  forall (left :: Symbol).
    Append (left :: Symbol) "World" "HelloWorld" => Proxy @Symbol (left :: Symbol)
deriveRight ::
  forall (right :: Symbol).
    Append "Hello" (right :: Symbol) "HelloWorld" => Proxy @Symbol (right :: Symbol)
appendEmpty ::
  forall (result :: Symbol). Append "" "test" (result :: Symbol) => Proxy @Symbol (result :: Symbol)
appendEmptyRight ::
  forall (result :: Symbol). Append "test" "" (result :: Symbol) => Proxy @Symbol (result :: Symbol)
compareLT ::
  forall (ord :: Ordering). Compare "a" "b" (ord :: Ordering) => Proxy @Ordering (ord :: Ordering)
compareEQ ::
  forall (ord :: Ordering).
    Compare "hello" "hello" (ord :: Ordering) => Proxy @Ordering (ord :: Ordering)
compareGT ::
  forall (ord :: Ordering). Compare "z" "a" (ord :: Ordering) => Proxy @Ordering (ord :: Ordering)
comparePrefix ::
  forall (ord :: Ordering).
    Compare "ab" "abc" (ord :: Ordering) => Proxy @Ordering (ord :: Ordering)
deriveCons ::
  forall (symbol :: Symbol). Cons "H" "ello" (symbol :: Symbol) => Proxy @Symbol (symbol :: Symbol)
deriveHeadTail ::
  forall (head :: Symbol) (tail :: Symbol).
    Cons (head :: Symbol) (tail :: Symbol) "World" => Proxy @Symbol (head :: Symbol)
consEmptyTail ::
  forall (symbol :: Symbol). Cons "X" "" (symbol :: Symbol) => Proxy @Symbol (symbol :: Symbol)
consSingleChar ::
  forall (head :: Symbol) (tail :: Symbol).
    Cons (head :: Symbol) (tail :: Symbol) "A" => Proxy @Symbol (tail :: Symbol)
forceSolve ::
  { appendEmpty :: Proxy @Symbol "test"
  , appendEmptyRight :: Proxy @Symbol "test"
  , compareEQ :: Proxy @Ordering EQ
  , compareGT :: Proxy @Ordering GT
  , compareLT :: Proxy @Ordering LT
  , comparePrefix :: Proxy @Ordering LT
  , consEmptyTail :: Proxy @Symbol "X"
  , consSingleChar :: Proxy @Symbol ""
  , deriveAppended :: Proxy @Symbol "HelloWorld"
  , deriveCons :: Proxy @Symbol "Hello"
  , deriveHeadTail :: Proxy @Symbol "W"
  , deriveLeft :: Proxy @Symbol "Hello"
  , deriveRight :: Proxy @Symbol "World"
  }

Types
Proxy :: forall (k :: Type). (k :: Type) -> Type

Data
Proxy
  Quantified = :0
  Kind = :1


Roles
Proxy = [Phantom]
