---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
MyUnit :: MyUnit
Identity :: forall (a :: Type). (a :: Type) -> Identity (a :: Type)
Left :: forall (a :: Type) (b :: Type). (a :: Type) -> Either (a :: Type) (b :: Type)
Right :: forall (a :: Type) (b :: Type). (b :: Type) -> Either (a :: Type) (b :: Type)
Tuple :: forall (a :: Type) (b :: Type). (a :: Type) -> (b :: Type) -> Tuple (a :: Type) (b :: Type)
Wrapper :: forall (a :: Type). (a :: Type) -> Wrapper (a :: Type)
Proxy :: forall (t6 :: Type) (a :: (t6 :: Type)). Proxy @(t6 :: Type) (a :: ???)
getVoid :: forall (rep :: Type). Generic Void (rep :: Type) => Proxy @Type (rep :: Type)
getMyUnit :: forall (rep :: Type). Generic MyUnit (rep :: Type) => Proxy @Type (rep :: Type)
getIdentity ::
  forall (a :: Type) (rep :: Type).
    Generic (Identity (a :: Type)) (rep :: Type) => Proxy @Type (rep :: Type)
getEither ::
  forall (a :: Type) (b :: Type) (rep :: Type).
    Generic (Either (a :: Type) (b :: Type)) (rep :: Type) => Proxy @Type (rep :: Type)
getTuple ::
  forall (a :: Type) (b :: Type) (rep :: Type).
    Generic (Tuple (a :: Type) (b :: Type)) (rep :: Type) => Proxy @Type (rep :: Type)
getWrapper ::
  forall (a :: Type) (rep :: Type).
    Generic (Wrapper (a :: Type)) (rep :: Type) => Proxy @Type (rep :: Type)
forceSolve ::
  forall (t65 :: Type) (t67 :: Type) (t68 :: Type) (t70 :: Type) (t71 :: Type) (t73 :: Type).
    { getEither ::
        Proxy @Type
          (Sum
            (Constructor "Left" (Argument (t67 :: Type)))
            (Constructor "Right" (Argument (t68 :: Type))))
    , getIdentity :: Proxy @Type (Constructor "Identity" (Argument (t65 :: Type)))
    , getMyUnit :: Proxy @Type (Constructor "MyUnit" NoArguments)
    , getTuple ::
        Proxy @Type
          (Constructor "Tuple" (Product (Argument (t70 :: Type)) (Argument (t71 :: Type))))
    , getVoid :: Proxy @Type NoConstructors
    , getWrapper :: Proxy @Type (Constructor "Wrapper" (Argument (t73 :: Type)))
    }

Types
Void :: Type
MyUnit :: Type
Identity :: Type -> Type
Either :: Type -> Type -> Type
Tuple :: Type -> Type -> Type
Wrapper :: Type -> Type
Proxy :: forall (t6 :: Type). (t6 :: Type) -> Type

Data
Void
  Quantified = :0
  Kind = :0

MyUnit
  Quantified = :0
  Kind = :0

Identity
  Quantified = :0
  Kind = :0

Either
  Quantified = :0
  Kind = :0

Tuple
  Quantified = :0
  Kind = :0

Wrapper
  Quantified = :0
  Kind = :0

Proxy
  Quantified = :1
  Kind = :0


Roles
Void = []
MyUnit = []
Identity = [Representational]
Either = [Representational, Representational]
Tuple = [Representational, Representational]
Wrapper = [Representational]
Proxy = [Phantom]

Derived
derive Generic (Void :: Type) (NoConstructors :: Type)
derive Generic (MyUnit :: Type) (Constructor "MyUnit" NoArguments :: Type)
derive Generic (Identity (&0 :: Type) :: Type) (Constructor "Identity" (Argument (&0 :: Type)) :: Type)
derive Generic (Either (&0 :: Type) (&1 :: Type) :: Type) (Sum (Constructor "Left" (Argument (&0 :: Type))) (Constructor "Right" (Argument (&1 :: Type))) :: Type)
derive Generic (Tuple (&0 :: Type) (&1 :: Type) :: Type) (Constructor "Tuple" (Product (Argument (&0 :: Type)) (Argument (&1 :: Type))) :: Type)
derive Generic (Wrapper (&0 :: Type) :: Type) (Constructor "Wrapper" (Argument (&0 :: Type)) :: Type)
