---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
Identity :: forall (a :: Type). (a :: Type) -> Identity (a :: Type)
ReaderT ::
  forall (r :: Type) (m :: Type -> Type) (a :: Type).
    ((r :: Type) -> (m :: Type -> Type) (a :: Type)) ->
    ReaderT (r :: Type) (m :: Type -> Type) (a :: Type)
StateT ::
  forall (s :: Type) (m :: Type -> Type) (a :: Type).
    ((s :: Type) -> (m :: Type -> Type) (Tuple (a :: Type) (s :: Type))) ->
    StateT (s :: Type) (m :: Type -> Type) (a :: Type)
Tuple :: forall (a :: Type) (b :: Type). (a :: Type) -> (b :: Type) -> Tuple (a :: Type) (b :: Type)

Types
Identity :: Type -> Type
ReaderT :: Type -> (Type -> Type) -> Type -> Type
StateT :: Type -> (Type -> Type) -> Type -> Type
Tuple :: Type -> Type -> Type
Reader :: Type -> Type -> Type
State :: Type -> Type -> Type
Apply :: forall (k :: Type) (l :: Type). ((k :: Type) -> (l :: Type)) -> (k :: Type) -> (l :: Type)
ReaderInt :: Type
StateString :: Type
NestedReader :: Type

Synonyms
Reader = forall (r :: Type). ReaderT (r :: Type) Identity
  Quantified = :0
  Kind = :0
  Type = :1

State = forall (s :: Type). StateT (s :: Type) Identity
  Quantified = :0
  Kind = :0
  Type = :1

Apply = forall (k :: Type) (l :: Type) (f :: (k :: Type) -> (l :: Type)) (a :: (k :: Type)).
  (f :: (k :: Type) -> (l :: Type)) (a :: (k :: Type))
  Quantified = :0
  Kind = :2
  Type = :2

ReaderInt = Apply (Reader Int) String
  Quantified = :0
  Kind = :0
  Type = :0

StateString = Apply (State String) Int
  Quantified = :0
  Kind = :0
  Type = :0

NestedReader = Apply (Apply (ReaderT Int) Identity) Boolean
  Quantified = :0
  Kind = :0
  Type = :0


Data
Identity
  Quantified = :0
  Kind = :0

ReaderT
  Quantified = :0
  Kind = :0

StateT
  Quantified = :0
  Kind = :0

Tuple
  Quantified = :0
  Kind = :0


Roles
Identity = [Representational]
ReaderT = [Representational, Representational, Nominal]
StateT = [Representational, Representational, Representational]
Tuple = [Representational, Representational]
