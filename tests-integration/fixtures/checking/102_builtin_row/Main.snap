---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
Proxy :: forall (k :: Type) (a :: k). Proxy @k a
deriveUnion :: forall (u :: Row Type). Union @Type ( a :: Int ) ( b :: String ) u => Proxy @(Row Type) u
deriveUnionLeft :: forall (l :: Row Type). Union @Type l ( b :: String ) ( a :: Int, b :: String ) => Proxy @(Row Type) l
deriveUnionRight :: forall (r :: Row Type). Union @Type ( a :: Int ) r ( a :: Int, b :: String ) => Proxy @(Row Type) r
unionEmptyLeft :: forall (u :: Row Type). Union @Type () ( a :: Int ) u => Proxy @(Row Type) u
unionEmptyRight :: forall (u :: Row Type). Union @Type ( a :: Int ) () u => Proxy @(Row Type) u
unionBothEmpty :: forall (t43 :: Type) (u :: Row t43). Union @t43 () () u => Proxy @(Row t43) u
unionMultiple :: forall (u :: Row Type). Union @Type ( a :: Int, b :: String ) ( c :: Boolean ) u => Proxy @(Row Type) u
deriveCons :: forall (row :: Row Type). Cons @Type "name" String () row => Proxy @(Row Type) row
deriveTail :: forall (tail :: Row Type). Cons @Type "name" String tail ( age :: Int, name :: String ) => Proxy @(Row Type) tail
deriveType :: forall (t :: Type). Cons @Type "name" t () ( name :: String ) => Proxy @Type t
nestedCons :: forall (row :: Row Type). Cons @Type "a" Int ( b :: String ) row => Proxy @(Row Type) row
lacksSimple :: forall (t82 :: Type) (r :: t82). Lacks @Type "missing" ( a :: Int, b :: String ) => Proxy @t82 r -> Proxy @t82 r
lacksEmpty :: forall (t90 :: Type) (t84 :: Type) (r :: t90). Lacks @t84 "anything" () => Proxy @t90 r -> Proxy @t90 r
nubNoDuplicates :: forall (nubbed :: Row Type). Nub @Type ( a :: Int, b :: String ) nubbed => Proxy @(Row Type) nubbed
nubEmpty :: forall (t100 :: Type) (nubbed :: Row t100). Nub @t100 () nubbed => Proxy @(Row t100) nubbed
rowToListSimple :: forall (list :: RowList Type). RowToList @Type ( a :: Int ) list => Proxy @(RowList Type) list
rowToListMultiple :: forall (list :: RowList Type). RowToList @Type ( a :: Int, b :: String ) list => Proxy @(RowList Type) list
rowToListEmpty :: forall (t116 :: Type) (list :: RowList t116). RowToList @t116 () list => Proxy @(RowList t116) list
rowToListThree :: forall (list :: RowList Type). RowToList @Type ( a :: Int, b :: String, c :: Boolean ) list => Proxy @(RowList Type) list
solveUnion :: forall (t180 :: Type). { deriveUnion :: Proxy @(Row Type) ( a :: Int, b :: String ), deriveUnionLeft :: Proxy @(Row Type) ( a :: Int ), deriveUnionRight :: Proxy @(Row Type) ( b :: String ), unionBothEmpty :: Proxy @(Row t180) (), unionEmptyLeft :: Proxy @(Row Type) ( a :: Int ), unionEmptyRight :: Proxy @(Row Type) ( a :: Int ), unionMultiple :: Proxy @(Row Type) ( a :: Int, b :: String, c :: Boolean ) }
solveCons :: { deriveCons :: Proxy @(Row Type) ( name :: String ), deriveTail :: Proxy @(Row Type) ( age :: Int ), deriveType :: Proxy @Type String, nestedCons :: Proxy @(Row Type) ( a :: Int, b :: String ) }
solveLacks :: forall (t197 :: Type) (t198 :: t197) (t201 :: Type) (t203 :: t201). { lacksEmpty :: Proxy @t201 t203, lacksSimple :: Proxy @t197 t198 }
solveNub :: forall (t214 :: Type). { nubEmpty :: Proxy @(Row t214) (), nubNoDuplicates :: Proxy @(Row Type) ( a :: Int, b :: String ) }
solveRowToList :: forall (t222 :: Type). { rowToListEmpty :: Proxy @(RowList t222) (Nil @t222), rowToListMultiple :: Proxy @(RowList Type) (Cons @Type "a" Int (Cons @Type "b" String (Nil @Type))), rowToListSimple :: Proxy @(RowList Type) (Cons @Type "a" Int (Nil @Type)), rowToListThree :: Proxy @(RowList Type) (Cons @Type "a" Int (Cons @Type "b" String (Cons @Type "c" Boolean (Nil @Type)))) }

Types
Proxy :: forall (k :: Type). k -> Type
