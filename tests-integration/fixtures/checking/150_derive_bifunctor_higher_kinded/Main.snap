---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
WrapBoth ::
  forall (t6 :: Type) (t10 :: Type) (f :: (t6 :: Type) -> Type) (g :: (t10 :: Type) -> Type)
    (a :: (t6 :: Type)) (b :: (t10 :: Type)).
    (f :: ??? -> Type) (a :: ???) ->
    (g :: ??? -> Type) (b :: ???) ->
    WrapBoth @(t6 :: Type) @(t10 :: Type)
      (f :: ??? -> Type)
      (g :: ??? -> Type)
      (a :: ???)
      (b :: ???)
WrapBothNoConstraint ::
  forall (t18 :: Type) (t22 :: Type) (f :: (t18 :: Type) -> Type) (g :: (t22 :: Type) -> Type)
    (a :: (t18 :: Type)) (b :: (t22 :: Type)).
    (f :: ??? -> Type) (a :: ???) ->
    (g :: ??? -> Type) (b :: ???) ->
    WrapBothNoConstraint @(t18 :: Type) @(t22 :: Type)
      (f :: ??? -> Type)
      (g :: ??? -> Type)
      (a :: ???)
      (b :: ???)

Types
WrapBoth ::
  forall (t6 :: Type) (t10 :: Type).
    ((t6 :: Type) -> Type) -> ((t10 :: Type) -> Type) -> (t6 :: Type) -> (t10 :: Type) -> Type
WrapBothNoConstraint ::
  forall (t18 :: Type) (t22 :: Type).
    ((t18 :: Type) -> Type) -> ((t22 :: Type) -> Type) -> (t18 :: Type) -> (t22 :: Type) -> Type

Data
WrapBoth
  Quantified = :2
  Kind = :0

WrapBothNoConstraint
  Quantified = :2
  Kind = :0


Roles
WrapBoth = [Representational, Representational, Nominal, Nominal]
WrapBothNoConstraint = [Representational, Representational, Nominal, Nominal]

Derived
derive (Functor (&0 :: Type -> Type), Functor (&1 :: Type -> Type)) => Bifunctor (WrapBoth @Type @Type (&0 :: Type -> Type) (&1 :: Type -> Type) :: Type -> Type -> Type)
derive Bifunctor (WrapBothNoConstraint @Type @Type (&0 :: Type -> Type) (&1 :: Type -> Type) :: Type -> Type -> Type)

Errors
NoInstanceFound { Functor (&0 :: Type -> Type) } at [TermDeclaration(Idx::<TermItem>(3))]
NoInstanceFound { Functor (&1 :: Type -> Type) } at [TermDeclaration(Idx::<TermItem>(3))]
