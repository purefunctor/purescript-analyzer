---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
bind ::
  forall (countL :: Int) (countR :: Int) (countLR :: Int) (countOut :: Int) (fieldNum :: Symbol)
    (fieldName :: Symbol) (a :: Type) (b :: Type) (r :: Row Type) (r' :: Row Type) (s :: Row Type).
    Add (countL :: Int) (countR :: Int) (countLR :: Int) =>
    Add (countLR :: Int) 1 (countOut :: Int) =>
    ToString (countOut :: Int) (fieldNum :: Symbol) =>
    Append "_" (fieldNum :: Symbol) (fieldName :: Symbol) =>
    Cons @Type (fieldName :: Symbol) (a :: Type) (r :: Row Type) (r' :: Row Type) =>
    Collector (countL :: Int) (s :: Row Type) (a :: Type) ->
    ((a :: Type) -> Collector (countR :: Int) (r :: Row Type) (b :: Type)) ->
    Collector (countOut :: Int) (r' :: Row Type) (b :: Type)
discard ::
  forall (countL :: Int) (countR :: Int) (countLR :: Int) (countOut :: Int) (fieldNum :: Symbol)
    (fieldName :: Symbol) (a :: Type) (b :: Type) (r :: Row Type) (r' :: Row Type) (s :: Row Type).
    Add (countL :: Int) (countR :: Int) (countLR :: Int) =>
    Add (countLR :: Int) 1 (countOut :: Int) =>
    ToString (countOut :: Int) (fieldNum :: Symbol) =>
    Append "_" (fieldNum :: Symbol) (fieldName :: Symbol) =>
    Cons @Type (fieldName :: Symbol) (a :: Type) (r :: Row Type) (r' :: Row Type) =>
    Collector (countL :: Int) (s :: Row Type) (a :: Type) ->
    ((a :: Type) -> Collector (countR :: Int) (r :: Row Type) (b :: Type)) ->
    Collector (countOut :: Int) (r' :: Row Type) (b :: Type)
pure :: forall (a :: Type). (a :: Type) -> Collector 0 () (a :: Type)
test1 :: Collector 3 ( _1 :: Char, _2 :: String, _3 :: Int ) { x :: Int, y :: String, z :: Char }
test2 :: Collector 2 ( _1 :: Boolean, _2 :: Char ) { x :: Char, y :: Boolean }
test3 :: Collector 2 ( _1 :: String, _2 :: Int ) { y :: Int, z :: String }
test4 ::
  Collector
    10
    ( _10 :: { x :: Int, y :: String, z :: Char }
    , _3 :: { y :: Int, z :: String }
    , _6 :: { x :: Char, y :: Boolean }
    )
    { a :: { x :: Int, y :: String, z :: Char }
    , b :: { x :: Char, y :: Boolean }
    , c :: { y :: Int, z :: String }
    }

Types
Collector :: Int -> Row Type -> Type -> Type

Roles
Collector = [Nominal, Nominal, Nominal]
