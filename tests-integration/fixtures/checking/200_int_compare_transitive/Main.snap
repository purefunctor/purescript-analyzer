---
source: tests-integration/tests/checking/generated.rs
expression: report
---
Terms
Proxy :: forall (k :: Type) (a :: (k :: Type)). Proxy @(k :: Type) (a :: (k :: Type))
assertLesser ::
  forall (l :: Int) (r :: Int).
    Compare (l :: Int) (r :: Int) LT => Proxy @(Row Int) ( left :: (l :: Int), right :: (r :: Int) )
assertGreater ::
  forall (l :: Int) (r :: Int).
    Compare (l :: Int) (r :: Int) GT => Proxy @(Row Int) ( left :: (l :: Int), right :: (r :: Int) )
assertEqual ::
  forall (l :: Int) (r :: Int).
    Compare (l :: Int) (r :: Int) EQ => Proxy @(Row Int) ( left :: (l :: Int), right :: (r :: Int) )
symmLt ::
  forall (m :: Int) (n :: Int).
    Compare (m :: Int) (n :: Int) GT => Proxy @(Row Int) ( left :: (n :: Int), right :: (m :: Int) )
symmGt ::
  forall (m :: Int) (n :: Int).
    Compare (m :: Int) (n :: Int) LT => Proxy @(Row Int) ( left :: (n :: Int), right :: (m :: Int) )
symmEq ::
  forall (m :: Int) (n :: Int).
    Compare (m :: Int) (n :: Int) EQ => Proxy @(Row Int) ( left :: (n :: Int), right :: (m :: Int) )
reflEq :: forall (n :: Int). Proxy @(Row Int) ( left :: (n :: Int), right :: (n :: Int) )
transLt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (m :: Int) (n :: Int) LT =>
    Compare (n :: Int) (p :: Int) LT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transLtEq ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (m :: Int) (n :: Int) LT =>
    Compare (n :: Int) (p :: Int) EQ =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transEqLt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (m :: Int) (n :: Int) EQ =>
    Compare (n :: Int) (p :: Int) LT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transGt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (m :: Int) (n :: Int) GT =>
    Compare (n :: Int) (p :: Int) GT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transGtEq ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (m :: Int) (n :: Int) GT =>
    Compare (n :: Int) (p :: Int) EQ =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transEqGt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (m :: Int) (n :: Int) EQ =>
    Compare (n :: Int) (p :: Int) GT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transEq ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (m :: Int) (n :: Int) EQ =>
    Compare (n :: Int) (p :: Int) EQ =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transSymmLt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (n :: Int) (m :: Int) GT =>
    Compare (n :: Int) (p :: Int) LT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transSymmLtEq ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (n :: Int) (m :: Int) GT =>
    Compare (n :: Int) (p :: Int) EQ =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transSymmEqLt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (n :: Int) (m :: Int) EQ =>
    Compare (n :: Int) (p :: Int) LT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transSymmGt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (n :: Int) (m :: Int) LT =>
    Compare (n :: Int) (p :: Int) GT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transSymmGtEq ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (n :: Int) (m :: Int) LT =>
    Compare (n :: Int) (p :: Int) EQ =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transSymmEqGt ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (n :: Int) (m :: Int) EQ =>
    Compare (n :: Int) (p :: Int) GT =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )
transSymmEq ::
  forall (m :: Int) (n :: Int) (p :: Int).
    Compare (n :: Int) (m :: Int) EQ =>
    Compare (n :: Int) (p :: Int) EQ =>
    Proxy @Int (n :: Int) -> Proxy @(Row Int) ( left :: (m :: Int), right :: (p :: Int) )

Types
Proxy :: forall (k :: Type). (k :: Type) -> Type

Data
Proxy
  Quantified = :0
  Kind = :1


Roles
Proxy = [Phantom]
