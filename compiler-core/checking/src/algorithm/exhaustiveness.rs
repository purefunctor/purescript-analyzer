mod convert;
mod pretty;

use std::iter;

use building_types::QueryResult;
use files::FileId;
use indexing::TermItemId;
use itertools::Itertools;
use rustc_hash::FxHashSet;
use smol_str::SmolStr;

use crate::algorithm::state::{CheckContext, CheckState};
use crate::algorithm::{derive, toolkit};
use crate::{ExternalQueries, TypeId};

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Pattern {
    pub kind: PatternKind,
    pub t: TypeId,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum PatternKind {
    Wildcard,
    Constructor { constructor: PatternConstructor },
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum PatternConstructor {
    DataConstructor { file_id: FileId, item_id: TermItemId, fields: Vec<PatternId> },
    Record { labels: Vec<SmolStr>, fields: Vec<PatternId> },
    Array { fields: Vec<PatternId> },
    Boolean(bool),
    Integer(i32),
    Number(bool, SmolStr),
    String(SmolStr),
    Char(char),
}

impl PatternConstructor {
    /// Returns the arity of this pattern constructor.
    ///
    /// [`PatternConstructor::DataConstructor`], [`PatternConstructor::Record`],
    /// and [`PatternConstructor::Array`] have non-zero arity based on their fields.
    pub fn arity(&self) -> usize {
        match self {
            PatternConstructor::DataConstructor { fields, .. } => fields.len(),
            PatternConstructor::Record { fields, .. } => fields.len(),
            PatternConstructor::Array { fields } => fields.len(),
            _ => 0,
        }
    }

    /// Returns the fields of this pattern constructor.
    ///
    /// [`PatternConstructor::DataConstructor`], [`PatternConstructor::Record`],
    /// and [`PatternConstructor::Array`] have fields corresponding to their arguments.
    pub fn fields(&self) -> &[PatternId] {
        match self {
            PatternConstructor::DataConstructor { fields, .. } => fields,
            PatternConstructor::Record { fields, .. } => fields,
            PatternConstructor::Array { fields } => fields,
            _ => &[],
        }
    }

    /// Checks if a pattern constructor matches another.
    ///
    /// This is used during the specialisation algorithm to determine if a
    /// pattern row should be included in the specialised pattern matrix.
    pub fn matches(&self, other: &PatternConstructor) -> bool {
        match (self, other) {
            (
                PatternConstructor::DataConstructor { file_id: f1, item_id: i1, .. },
                PatternConstructor::DataConstructor { file_id: f2, item_id: i2, .. },
            ) => f1 == f2 && i1 == i2,
            // Any record constructor matches any other record constructor
            (PatternConstructor::Record { .. }, PatternConstructor::Record { .. }) => true,
            // Array constructors match only when their lengths match
            (
                PatternConstructor::Array { fields: f1 },
                PatternConstructor::Array { fields: f2 },
            ) => f1.len() == f2.len(),
            (PatternConstructor::Boolean(b1), PatternConstructor::Boolean(b2)) => b1 == b2,
            (PatternConstructor::Integer(i1), PatternConstructor::Integer(i2)) => i1 == i2,
            (PatternConstructor::Number(n1, v1), PatternConstructor::Number(n2, v2)) => {
                n1 == n2 && v1 == v2
            }
            (PatternConstructor::String(s1), PatternConstructor::String(s2)) => s1 == s2,
            (PatternConstructor::Char(c1), PatternConstructor::Char(c2)) => c1 == c2,
            _ => false,
        }
    }

    /// Reconstructs a [`PatternConstructor`] with the given fields.
    ///
    /// For [`PatternConstructor::DataConstructor`], [`PatternConstructor::Record`],
    /// and [`PatternConstructor::Array`], this function overrides the fields.
    /// Otherwise, the fields must be empty as enforced by an assertion.
    ///
    /// This algorithm is used in [`algorithm_m`] to replace the fields of the
    /// pattern constructor we're specialising on with the fields generated by
    /// the witnesses.
    pub fn reconstruct(&self, fields: &[PatternId]) -> PatternConstructor {
        match *self {
            PatternConstructor::DataConstructor { file_id, item_id, .. } => {
                let fields = fields.to_vec();
                PatternConstructor::DataConstructor { file_id, item_id, fields }
            }
            PatternConstructor::Record { ref labels, .. } => {
                let fields = fields.to_vec();
                PatternConstructor::Record { labels: labels.clone(), fields }
            }
            PatternConstructor::Array { .. } => {
                let fields = fields.to_vec();
                PatternConstructor::Array { fields }
            }
            PatternConstructor::Boolean(b) => {
                assert!(fields.is_empty(), "Boolean constructor has arity 0");
                PatternConstructor::Boolean(b)
            }
            PatternConstructor::Integer(i) => {
                assert!(fields.is_empty(), "Integer constructor has arity 0");
                PatternConstructor::Integer(i)
            }
            PatternConstructor::Number(negative, ref n) => {
                assert!(fields.is_empty(), "Number constructor has arity 0");
                PatternConstructor::Number(negative, SmolStr::clone(n))
            }
            PatternConstructor::String(ref s) => {
                assert!(fields.is_empty(), "String constructor has arity 0");
                PatternConstructor::String(SmolStr::clone(s))
            }
            PatternConstructor::Char(c) => {
                assert!(fields.is_empty(), "Char constructor has arity 0");
                PatternConstructor::Char(c)
            }
        }
    }
}

impl MissingConstructor {
    /// Constructs a witness pattern for this missing constructor.
    pub fn construct_missing_witness(&self, state: &mut CheckState, t: TypeId) -> PatternId {
        match *self {
            MissingConstructor::DataConstructor { file_id, item_id, ref fields } => {
                let fields = fields
                    .iter()
                    .map(|&field_type| state.allocate_wildcard(field_type))
                    .collect_vec();

                let constructor = PatternConstructor::DataConstructor { file_id, item_id, fields };
                let pattern = PatternKind::Constructor { constructor };

                state.allocate_pattern(pattern, t)
            }
            MissingConstructor::Boolean(b) => {
                let constructor = PatternConstructor::Boolean(b);
                let pattern = PatternKind::Constructor { constructor };
                state.allocate_pattern(pattern, t)
            }
        }
    }
}

pub type PatternId = interner::Id<Pattern>;
pub type PatternStorage = interner::Interner<Pattern>;

type PatternVector = Vec<PatternId>;
type PatternMatrix = Vec<PatternVector>;
pub type WitnessVector = Vec<PatternId>;

/// Determines if a [`PatternVector`] is useful with respect to a [`PatternMatrix`].
///
/// A pattern vector is useful if it matches at least one value not matched by
/// any pattern vector in the matrix. This is one of the core algorithms from
/// Maranget's "Warnings for pattern matching" paper.
///
/// See [`algorithm_u_constructor`] and [`algorithm_u_wildcard`] for reference.
fn algorithm_u<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
) -> QueryResult<bool>
where
    Q: ExternalQueries,
{
    // Base case: any pattern is useful against an empty matrix
    if matrix.is_empty() {
        return Ok(true);
    }

    // Base case: an empty pattern vector against non-empty matrix is useless
    let [first_pattern, ..] = vector[..] else {
        return Ok(false);
    };

    let first_pattern = state.patterns[first_pattern].clone();

    match first_pattern.kind {
        PatternKind::Constructor { constructor } => {
            algorithm_u_constructor(state, context, matrix, vector, constructor)
        }
        PatternKind::Wildcard => {
            algorithm_u_wildcard(state, context, matrix, vector, first_pattern.t)
        }
    }
}

/// Induction 1
///
/// This function uses specialisation to spread the provided [`PatternConstructor`]
/// over both the [`PatternMatrix`] and the [`PatternVector`], before calling
/// [`algorithm_u`] recursively with the specialised structures.
fn algorithm_u_constructor<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
    constructor: PatternConstructor,
) -> QueryResult<bool>
where
    Q: ExternalQueries,
{
    let specialised_matrix = specialise_matrix(state, &constructor, matrix);

    let Some(specialised_vector) = specialise_vector(state, &constructor, vector) else {
        unreachable!("invariant violated: vector contains constructor");
    };

    algorithm_u(state, context, &specialised_matrix, &specialised_vector)
}

/// Induction 2
///
/// This function collects all constructor references from the first column of
/// the matrix into a collection called the sigma.
///
/// If the sigma is complete, for each constructor in the sigma, we specialise
/// the pattern matrix and pattern vector against it. Then, we recursively call
/// [`algorithm_u`] against the specialised structures. The pattern vector is
/// useful if any specialised pattern vector is useful against its specialised
/// pattern matrix.
///
/// If the sigma is incomplete, we recursively call [`algorithm_u`] against the
/// [`default_matrix`] of the pattern matrix and the tail of the pattern vector.
fn algorithm_u_wildcard<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
    t: TypeId,
) -> QueryResult<bool>
where
    Q: ExternalQueries,
{
    let sigma = collect_sigma(state, context, matrix, t)?;
    let complete = sigma_is_complete(context, &sigma)?;

    if complete {
        algorithm_u_wildcard_complete(state, context, matrix, vector, sigma)
    } else {
        algorithm_u_wildcard_incomplete(state, context, matrix, vector)
    }
}

fn algorithm_u_wildcard_complete<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
    sigma: Sigma,
) -> QueryResult<bool>
where
    Q: ExternalQueries,
{
    for constructor in sigma.constructors {
        let specialised_matrix = specialise_matrix(state, &constructor, matrix);

        let Some(specialised_vector) = specialise_vector(state, &constructor, vector) else {
            unreachable!("invariant violated: vector contains constructor");
        };

        if algorithm_u(state, context, &specialised_matrix, &specialised_vector)? {
            return Ok(true);
        }
    }
    Ok(false)
}

fn algorithm_u_wildcard_incomplete<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
) -> QueryResult<bool>
where
    Q: ExternalQueries,
{
    let default = default_matrix(state, matrix);
    let tail_columns = vector[1..].to_vec();
    algorithm_u(state, context, &default, &tail_columns)
}

/// Determines the matching [`WitnessVector`] given a [`PatternMatrix`]
/// and some [`PatternVector`].
///
/// If the pattern vector is useful against the provided matrix, that is,
/// there are cases yet to be covered, this function will return a non-empty
/// list of witnesses. Inversely, if the pattern vector is useless against
/// the provided matrix, that is, the cases are exhaustive, this function
/// will return [`None`].
///
/// So... what exactly are witnesses? In the paper, these are defined as
/// 'value vectors' that are known not to be matched against the pattern
/// matrix but are instantiations of the pattern vector. In our implementation,
/// these witnesses are pattern vectors that denote values not yet covered by
/// the matrix.
///
/// The [`algorithm_m_wildcard`] induction is prolific for producing these
/// these witnesses as it compares the constructors that appear in the
/// matrix against the constructors available in the checking environment.
fn algorithm_m<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
) -> QueryResult<Option<Vec<WitnessVector>>>
where
    Q: ExternalQueries,
{
    // Base case: any pattern is its own witness against an empty matrix
    if matrix.is_empty() {
        let vector = vector.clone();
        return Ok(Some(vec![vector]));
    }

    // Base case: an empty pattern vector against non-empty matrix has no witnesses
    let [first_pattern, ..] = vector[..] else {
        return Ok(None);
    };

    let first_pattern = state.patterns[first_pattern].clone();

    match first_pattern.kind {
        PatternKind::Constructor { constructor } => {
            algorithm_m_constructor(state, context, matrix, vector, constructor, first_pattern.t)
        }
        PatternKind::Wildcard => {
            algorithm_m_wildcard(state, context, matrix, vector, first_pattern.t)
        }
    }
}

/// Induction 1
///
/// This function uses specialisation to spread the provided [`PatternConstructor`]
/// over both the [`PatternMatrix`] and the [`PatternVector`], before calling
/// [`algorithm_m`] recursively with the specialised structures.
///
/// The final set of witnesses returned by this induction includes a
/// reconstruction of the original constructor passed to this function.
///
/// See documentation for [`specialise_matrix`] and [`specialise_vector`] for
/// more information on what specialisation entails given a constructor.
fn algorithm_m_constructor<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
    constructor: PatternConstructor,
    t: TypeId,
) -> QueryResult<Option<Vec<WitnessVector>>>
where
    Q: ExternalQueries,
{
    let arity = constructor.arity();

    let specialised_matrix = specialise_matrix(state, &constructor, matrix);

    let Some(specialised_vector) = specialise_vector(state, &constructor, vector) else {
        unreachable!("invariant violated: vector contains constructor");
    };

    let witnesses = algorithm_m(state, context, &specialised_matrix, &specialised_vector)?;

    let Some(witnesses) = witnesses else {
        return Ok(None);
    };

    let witnesses = witnesses.into_iter().map(|witness| {
        let (argument_columns, tail_columns) = witness.split_at(arity);

        let constructor = constructor.reconstruct(argument_columns);
        let constructor_id = state.allocate_constructor(constructor, t);
        let tail_columns = tail_columns.iter().copied();

        iter::once(constructor_id).chain(tail_columns).collect()
    });

    let witnesses = witnesses.collect();
    Ok(Some(witnesses))
}

/// Induction 2
///
/// If the first column in the [`PatternVector`] is a wildcard, this function
/// produces witnesses that correspond to patterns not yet covered by the
/// [`PatternMatrix`]. This is where pattern suggestion warnings are built
/// for the compiler!
///
/// This function collects all constructor references from the first column
/// of all rows in the matrix into a collection called the sigma. We handle
/// the structure in different ways:
///
/// If the sigma is complete, for each constructor in the sigma, we apply
/// a rule similar to [`algorithm_m_constructor`] to collect witnesses
/// across all constructors.
///
/// If the sigma is incomplete, we recursively apply [`algorithm_m`] to the
/// [`default_matrix`] of the pattern matrix and the tail columns of the
/// pattern vector. The induction ends if the recursive call is exhaustive.
///
/// If the recursive call returns witnesses, and the sigma is non-empty,
/// we move our attention to generating [`Constructor`] patterns for
/// constructors not present in the sigma. This is what we use for
/// reporting pattern warnings. Otherwise, if the sigma is empty, we
/// simply produce a wildcard pattern.
fn algorithm_m_wildcard<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
    t: TypeId,
) -> QueryResult<Option<Vec<WitnessVector>>>
where
    Q: ExternalQueries,
{
    let sigma = collect_sigma(state, context, matrix, t)?;
    let complete = sigma_is_complete(context, &sigma)?;
    if complete {
        algorithm_m_wildcard_complete(state, context, matrix, vector, t, &sigma)
    } else {
        algorithm_m_wildcard_incomplete(state, context, matrix, vector, t, &sigma)
    }
}

fn algorithm_m_wildcard_complete<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
    t: TypeId,
    sigma: &Sigma,
) -> QueryResult<Option<Vec<WitnessVector>>>
where
    Q: ExternalQueries,
{
    let mut all_witnesses = vec![];

    for constructor in &sigma.constructors {
        let arity = constructor.arity();

        let specialised_matrix = specialise_matrix(state, constructor, matrix);

        let Some(specialised_vector) = specialise_vector(state, constructor, vector) else {
            unreachable!("invariant violated: vector contains constructor");
        };

        if let Some(witnesses) =
            algorithm_m(state, context, &specialised_matrix, &specialised_vector)?
        {
            for witness in witnesses {
                let (argument_columns, tail_columns) = witness.split_at(arity);

                let constructor = constructor.reconstruct(argument_columns);
                let constructor_id = state.allocate_constructor(constructor, t);
                let tail_columns = tail_columns.iter().copied();

                let witnesses = iter::once(constructor_id).chain(tail_columns).collect();
                all_witnesses.push(witnesses);
            }
        }
    }

    if all_witnesses.is_empty() { Ok(None) } else { Ok(Some(all_witnesses)) }
}

fn algorithm_m_wildcard_incomplete<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    vector: &PatternVector,
    t: TypeId,
    sigma: &Sigma,
) -> QueryResult<Option<Vec<WitnessVector>>>
where
    Q: ExternalQueries,
{
    let default = default_matrix(state, matrix);
    let tail_columns = vector[1..].to_vec();

    let witnesses = algorithm_m(state, context, &default, &tail_columns)?;

    let Some(witnesses) = witnesses else {
        return Ok(None);
    };

    let first_column = if let Some(constructor) = sigma.missing.first() {
        constructor.construct_missing_witness(state, t)
    } else {
        state.allocate_wildcard(t)
    };

    let witness = witnesses
        .into_iter()
        .map(|witness| iter::once(first_column).chain(witness).collect())
        .collect();

    Ok(Some(witness))
}

/// Specialises a [`PatternMatrix`] given a [`PatternConstructor`].
///
/// See documentation below for [`specialise_vector`].
fn specialise_matrix(
    state: &mut CheckState,
    expected: &PatternConstructor,
    matrix: &PatternMatrix,
) -> PatternMatrix {
    matrix.iter().filter_map(|row| specialise_vector(state, expected, row)).collect()
}

/// Specialises a [`PatternVector`] given a [`PatternConstructor`].
///
/// Specialisation takes a pattern vector and applies the following rules:
/// 1. If the first column is a wildcard, it expands it to `n` wildcards
///    where `n` is the arity of the expected [`PatternConstructor`].
///    For non-ADT constructors, arity is 0 (no expansion needed).
/// 2. It returns `None` for constructors that are not the expected
///    [`PatternConstructor`], which excludes them from the specialised matrix.
///    For example, a pattern vector specialised on `Just` removes `Nothing`.
/// 3. For matching constructors, it 'splats' the fields, effectively turning
///    a pattern vector like `[Just _]` into `[_]` or `[Nothing]` into `[]`.
///    For non-ADT constructors, arity is 0 so nothing is splatted.
fn specialise_vector(
    state: &mut CheckState,
    expected: &PatternConstructor,
    vector: &PatternVector,
) -> Option<PatternVector> {
    let [first_column, ref tail_columns @ ..] = vector[..] else {
        unreachable!("invariant violated: specialise_vector processed empty row");
    };

    let first_column = &state.patterns[first_column];

    if let PatternKind::Wildcard = first_column.kind {
        // Expand wildcard to the expected constructor's arity
        match expected {
            PatternConstructor::DataConstructor { fields, .. }
            | PatternConstructor::Record { fields, .. } => {
                let wildcards = fields.iter().map(|&pattern_id| {
                    let t = state.patterns[pattern_id].t;
                    state.allocate_wildcard(t)
                });
                let tail_columns = tail_columns.iter().copied();
                return Some(iter::chain(wildcards, tail_columns).collect());
            }
            PatternConstructor::Array { fields } => {
                let wildcards = fields.iter().map(|&pattern_id| {
                    let t = state.patterns[pattern_id].t;
                    state.allocate_wildcard(t)
                });
                let tail_columns = tail_columns.iter().copied();
                return Some(iter::chain(wildcards, tail_columns).collect());
            }
            _ => {
                return Some(tail_columns.to_vec());
            }
        }
    }

    let PatternKind::Constructor { constructor } = &first_column.kind else {
        return Some(tail_columns.to_vec());
    };

    // Check if constructors match
    if !constructor.matches(expected) {
        return None;
    }

    // Splat fields for constructors with arity
    match constructor {
        PatternConstructor::DataConstructor { fields, .. }
        | PatternConstructor::Record { fields, .. } => {
            Some(iter::chain(fields, tail_columns).copied().collect())
        }
        PatternConstructor::Array { fields } => {
            Some(iter::chain(fields, tail_columns).copied().collect())
        }
        _ => Some(tail_columns.to_vec()),
    }
}

fn default_matrix(state: &CheckState, matrix: &PatternMatrix) -> PatternMatrix {
    let filter_map = matrix.iter().filter_map(|row| {
        let [first_column, ref default_columns @ ..] = row[..] else {
            unreachable!("invariant violated: default_matrix processed empty row");
        };
        if let PatternKind::Wildcard = state.patterns[first_column].kind {
            Some(default_columns.to_vec())
        } else {
            None
        }
    });
    filter_map.collect()
}

/// Key for identifying a unique constructor.
#[derive(Clone, PartialEq, Eq, Hash)]
enum ConstructorKey {
    Data(FileId, TermItemId),
    Record,
    Array(usize),
    Boolean(bool),
    Integer(i32),
    Number(bool, SmolStr),
    String(SmolStr),
    Char(char),
}

impl ConstructorKey {
    fn from_pattern_constructor(pc: &PatternConstructor) -> Self {
        match pc {
            PatternConstructor::DataConstructor { file_id, item_id, .. } => {
                ConstructorKey::Data(*file_id, *item_id)
            }
            // All record constructors share the same key (single constructor semantics)
            PatternConstructor::Record { .. } => ConstructorKey::Record,
            // Array constructors are keyed by their length
            PatternConstructor::Array { fields } => ConstructorKey::Array(fields.len()),
            PatternConstructor::Boolean(b) => ConstructorKey::Boolean(*b),
            PatternConstructor::Integer(i) => ConstructorKey::Integer(*i),
            PatternConstructor::Number(negative, n) => {
                let n = SmolStr::clone(n);
                ConstructorKey::Number(*negative, n)
            }
            PatternConstructor::String(s) => {
                let s = SmolStr::clone(s);
                ConstructorKey::String(s)
            }
            PatternConstructor::Char(c) => ConstructorKey::Char(*c),
        }
    }
}

#[derive(Clone, Debug)]
struct Sigma {
    constructors: Vec<PatternConstructor>,
    missing: Vec<MissingConstructor>,
}

#[derive(Clone, Debug)]
enum MissingConstructor {
    DataConstructor { file_id: FileId, item_id: TermItemId, fields: Vec<TypeId> },
    Boolean(bool),
}

/// Extracts the sigma, a set of constructors from the first column of the matrix.
///
/// Returns a list of unique constructors seen in the first column, keeping one
/// representative [`PatternConstructor`] per distinct constructor. Other patterns
/// like wildcards, records, and arrays are ignored for now.
fn collect_sigma<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    matrix: &PatternMatrix,
    scrutinee_type: TypeId,
) -> QueryResult<Sigma>
where
    Q: ExternalQueries,
{
    let mut seen = FxHashSet::default();
    let mut constructors = vec![];

    for row in matrix {
        let [first_column, ..] = row[..] else {
            continue;
        };
        let pattern = &state.patterns[first_column];
        if let PatternKind::Constructor { constructor } = &pattern.kind {
            let key = ConstructorKey::from_pattern_constructor(constructor);
            if seen.insert(key) {
                constructors.push(constructor.clone());
            }
        }
    }

    let missing = collect_missing_constructors(state, context, scrutinee_type, &constructors)?;
    Ok(Sigma { constructors, missing })
}

/// Checks whether the set of constructors (sigma) is complete for the scrutinee type.
///
/// A sigma is complete if it contains all constructors of the data type.
/// For Boolean, both true and false must be present.
/// For records, there is exactly one constructor, so any record pattern makes sigma complete.
/// For other literal constructors (Integer, Number, String, Char), sigma is never complete
/// (infinite domains).
/// If we can't determine the type or its constructors, we conservatively return false.
fn sigma_is_complete<Q>(context: &CheckContext<Q>, sigma: &Sigma) -> QueryResult<bool>
where
    Q: ExternalQueries,
{
    // Empty sigma is never complete
    let Some(first) = sigma.constructors.first() else {
        return Ok(false);
    };

    match first {
        PatternConstructor::DataConstructor { file_id, item_id, .. } => {
            // Get the indexed module for the constructor's file
            let indexed = context.queries.indexed(*file_id)?;

            // Find the type this constructor belongs to
            let Some(type_item_id) = indexed.pairs.constructor_type(*item_id) else {
                return Ok(false);
            };

            // Get all constructors for this type
            let all_constructors: FxHashSet<TermItemId> =
                indexed.pairs.data_constructors(type_item_id).collect();

            // Check if sigma covers all constructors
            let sigma_terms: FxHashSet<TermItemId> = sigma
                .constructors
                .iter()
                .filter_map(|c| match c {
                    PatternConstructor::DataConstructor { item_id, .. } => Some(*item_id),
                    _ => None,
                })
                .collect();

            Ok(all_constructors.iter().all(|term_id| sigma_terms.contains(term_id)))
        }
        // Records have exactly one constructor, so sigma is always complete for records
        PatternConstructor::Record { .. } => Ok(true),
        // Arrays have infinite possible lengths, so sigma is never complete
        PatternConstructor::Array { .. } => Ok(false),
        PatternConstructor::Boolean(_) => {
            // Boolean is complete when both true and false are present
            let has_true =
                sigma.constructors.iter().any(|c| matches!(c, PatternConstructor::Boolean(true)));
            let has_false =
                sigma.constructors.iter().any(|c| matches!(c, PatternConstructor::Boolean(false)));
            Ok(has_true && has_false)
        }
        // Other literal constructors have infinite domains, so they're never complete
        PatternConstructor::Integer(_)
        | PatternConstructor::Number(_, _)
        | PatternConstructor::String(_)
        | PatternConstructor::Char(_) => Ok(false),
    }
}

fn collect_missing_constructors<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    scrutinee_type: TypeId,
    constructors: &[PatternConstructor],
) -> QueryResult<Vec<MissingConstructor>>
where
    Q: ExternalQueries,
{
    let Some(first_constructor) = constructors.first() else {
        return Ok(vec![]);
    };

    match first_constructor {
        PatternConstructor::DataConstructor { file_id, item_id, .. } => {
            let indexed = context.queries.indexed(*file_id)?;

            let Some(type_item_id) = indexed.pairs.constructor_type(*item_id) else {
                return Ok(vec![]);
            };

            let sigma: FxHashSet<TermItemId> = constructors
                .iter()
                .filter_map(|c| match c {
                    PatternConstructor::DataConstructor { item_id, .. } => Some(*item_id),
                    _ => None,
                })
                .collect();
            let arguments = toolkit::extract_all_applications(state, scrutinee_type);

            let mut missing = vec![];
            for missing_item_id in indexed.pairs.data_constructors(type_item_id) {
                if !sigma.contains(&missing_item_id) {
                    let fields = constructor_field_types(
                        state,
                        context,
                        *file_id,
                        missing_item_id,
                        &arguments,
                    )?;
                    missing.push(MissingConstructor::DataConstructor {
                        file_id: *file_id,
                        item_id: missing_item_id,
                        fields,
                    });
                }
            }

            Ok(missing)
        }
        // Arrays have infinite possible lengths, so we don't report specific missing values.
        // The algorithm will fall back to wildcard suggestion.
        PatternConstructor::Array { .. } => Ok(vec![]),
        PatternConstructor::Boolean(_) => {
            // Check which boolean values are missing
            let has_true =
                constructors.iter().any(|c| matches!(c, PatternConstructor::Boolean(true)));
            let has_false =
                constructors.iter().any(|c| matches!(c, PatternConstructor::Boolean(false)));
            let mut missing = vec![];
            if !has_true {
                missing.push(MissingConstructor::Boolean(true));
            }
            if !has_false {
                missing.push(MissingConstructor::Boolean(false));
            }
            Ok(missing)
        }
        // Other literal constructors have infinite domains, so we don't report specific missing values
        _ => Ok(vec![]),
    }
}

fn constructor_field_types<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    file_id: FileId,
    term_id: TermItemId,
    arguments: &[TypeId],
) -> QueryResult<Vec<TypeId>>
where
    Q: ExternalQueries,
{
    let constructor_type = derive::lookup_local_term_type(state, context, file_id, term_id)?;
    if let Some(constructor_type) = constructor_type {
        let (constructor, _) =
            toolkit::instantiate_with_arguments(state, constructor_type, arguments);
        let (fields, _) = toolkit::extract_function_arguments(state, constructor);
        Ok(fields)
    } else {
        let arity = get_constructor_arity(context, file_id, term_id)?;
        Ok(iter::repeat_n(context.prim.unknown, arity).collect())
    }
}

/// Gets the arity (number of fields) of a constructor.
fn get_constructor_arity<Q>(
    context: &CheckContext<Q>,
    file_id: FileId,
    term_id: TermItemId,
) -> QueryResult<usize>
where
    Q: ExternalQueries,
{
    let on_lowered = |lowered: &lowering::LoweredModule| {
        if let Some(lowering::TermItemIr::Constructor { arguments }) =
            lowered.info.get_term_item(term_id)
        {
            arguments.len()
        } else {
            0
        }
    };
    if file_id == context.id {
        let lowered = &context.lowered;
        Ok(on_lowered(lowered))
    } else {
        let lowered = context.queries.lowered(file_id)?;
        Ok(on_lowered(&lowered))
    }
}

pub struct ExhaustivenessReport {
    pub missing: Option<Vec<SmolStr>>,
    pub redundant: Vec<SmolStr>,
}

pub fn check_lambda_patterns<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    pattern_types: &[TypeId],
    binders: &[lowering::BinderId],
) -> QueryResult<ExhaustivenessReport>
where
    Q: ExternalQueries,
{
    if pattern_types.is_empty() {
        return Ok(ExhaustivenessReport { missing: None, redundant: vec![] });
    }

    let unconditional =
        collect_unconditional_rows(state, context, &[binders], pattern_types, |binders| {
            (binders, &None)
        })?;

    check_exhaustiveness_core(state, context, pattern_types, unconditional)
}

pub fn check_case_patterns<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    pattern_types: &[TypeId],
    branches: &[lowering::CaseBranch],
) -> QueryResult<ExhaustivenessReport>
where
    Q: ExternalQueries,
{
    if pattern_types.is_empty() {
        return Ok(ExhaustivenessReport { missing: None, redundant: vec![] });
    }

    let unconditional = collect_unconditional_rows(
        state,
        context,
        branches,
        pattern_types,
        |branch: &lowering::CaseBranch| (&branch.binders, &branch.guarded_expression),
    )?;

    check_exhaustiveness_core(state, context, pattern_types, unconditional)
}

pub fn check_equation_patterns<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    pattern_types: &[TypeId],
    equations: &[lowering::Equation],
) -> QueryResult<ExhaustivenessReport>
where
    Q: ExternalQueries,
{
    if pattern_types.is_empty() {
        return Ok(ExhaustivenessReport { missing: None, redundant: vec![] });
    }

    let unconditional = collect_unconditional_rows(
        state,
        context,
        equations,
        pattern_types,
        |equation: &lowering::Equation| (&equation.binders, &equation.guarded),
    )?;

    check_exhaustiveness_core(state, context, pattern_types, unconditional)
}

fn collect_unconditional_rows<Q, T, F>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    items: &[T],
    pattern_types: &[TypeId],
    to_binders: F,
) -> QueryResult<Vec<PatternVector>>
where
    Q: ExternalQueries,
    F: Fn(&T) -> (&[lowering::BinderId], &Option<lowering::GuardedExpression>),
{
    let mut pattern_rows = vec![];
    for item in items {
        let (binders, guarded) = to_binders(item);

        if !matches!(guarded, Some(lowering::GuardedExpression::Unconditional { .. }) | None) {
            continue;
        }

        let mut pattern_row = vec![];
        for &binder_id in binders {
            pattern_row.push(convert::convert_binder(state, context, binder_id)?);
        }

        let additional = pattern_types.iter().skip(pattern_row.len());
        pattern_row.extend(additional.map(|&t| state.allocate_wildcard(t)));

        if !pattern_row.is_empty() {
            pattern_rows.push(pattern_row);
        }
    }
    Ok(pattern_rows)
}

fn check_exhaustiveness_core<Q>(
    state: &mut CheckState,
    context: &CheckContext<Q>,
    pattern_types: &[TypeId],
    unconditional: PatternMatrix,
) -> QueryResult<ExhaustivenessReport>
where
    Q: ExternalQueries,
{
    let mut redundant = vec![];
    let mut matrix = vec![];
    for vector in &unconditional {
        let useful = algorithm_u(state, context, &matrix, vector)?;
        if useful {
            matrix.push(PatternVector::clone(vector));
        } else {
            redundant.push(pretty::pretty_witness(context, state, vector));
        }
    }

    let query = pattern_types.iter().map(|&t| state.allocate_wildcard(t)).collect();
    let witnesses = algorithm_m(state, context, &unconditional, &query)?;
    let missing = witnesses.map(|witnesses| {
        witnesses
            .iter()
            .take(5)
            .map(|witness| pretty::pretty_witness(context, state, witness))
            .collect()
    });

    Ok(ExhaustivenessReport { missing, redundant })
}
